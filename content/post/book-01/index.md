---
title: "A-01 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"
date: "2022-02-08"
description: "데이터 중심 어플리케이션 설계 1장"
author: Sunyoung Park (SoniaComp)
---

* 오늘날 많은 애플리케이션은 '계산 중심(compute-intensive)' 보다는 '데이터 중심(data-intensive)'
* CPU 성능은 애플리케이션을 제한하는 요소가 아님
* 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 더 큰 문제

### 데이터 중심 애플리케이션(데이터 시스템) 표준 구성 요소
1. Database: 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장
2. Cache: 읽기 속도 향상을 위해 값비싼 수행 결과를 기억
3. Search Index: 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공
4. Stream Processing: 비동기 처리를 위해 다른 프로세스로 메시지 보내기
5. Batch Processing: 주기적으로 대량의 누적된 데이터를 분석

현실에서 고려할 점
* 애플리케이션마다 요구사항이 달라서, DB 시스템마다 다양한 특성이 존재
* 캐싱을 위한 다양한 접근 방식
* 검색 색인을 구축하는 여러가지 방법
* 어떤 도구와 어떤 접근 방식이 수행중인 작업에 가장 적합한지 생각해야 한다.

## 1. 데이터 시스템에 대한 생각
![An Example of DataSystem Architecture](https://ebrary.net/htm/img/15/554/3.png)
(출처: https://ebrary.net/64599/computer_science/thinking_data_systems)
* 메인 DB와 분리된 애플리케이션 관리 계층
* 메인 DB와 분리된 전문(full-text) 검색 서버
* DIAD 애플리케이션 코드: 메인 DB와 두 계층을 동기화하는 작업

**새로운 용어의 필요성**</br>
1. 새로운 도구들은 다양한 사용 사례(use case)에 최적화되어 전통적인 시스템 분류에 딱 들어맞지 않게 되었다.
    * 레디스(Redis): 메시지 큐로 사용하는 데이터 스토어(datastore)
    * 카프카(Apache Kafka): 데이터 베이스처럼 지속성을 보장하는 메시지 큐
2. 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 가짐
    * 하나의 작업(work) => 여러개의 태스크(task)로 나눔
    * 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결

## 2. 신뢰성(reliability)
역경에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 함</br>
비용을 줄이려 신뢰성을 희생해야 하는 상황이 있다. 하지만, 이 경우에는 비용을 줄여야 하는 시점을 매우 잘 알고 있어야 한다.


**소프트웨어에 대한 기대치**</br>
* 사용자가 기대한 기능 수행
* 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법 허용
* 시스템 성능은 예상된 부하와 데이터 양에서 필수적으로 사용 사례를 충분히 만족
* 허가되지 않은 접근과 오남용을 방지

**용어**</br>
* 장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우
* 결함(fault): 잘못될 수 있는 일. 사양에서 벗어난 시스템의 한 구성 요소
* 내결함성(fault-tolerant), 탄력성(resilient): 결함을 예측하고 대처할 수 있는 시스템. 최종 사용자에게 각각의 특정 유형의 결함을 숨길 수 있게 함.

### 2-1. 하드웨어 결함
* 하드디스크가 고장
* 램에 결함
* 대규모 정전 사태
* 네트워크 케이블을 잘못 뽑은 경우

**해결 방법**</br>
1. 하드웨어 구성 요소에 중복(redundancy) 추가 [단일 장비 신뢰성]
2. 유연성(flexibility), 탄력성(elasticity)

### 2-2. 소프트웨어 오류
* 시스템 내 체계적 오류(systematic error)

**해결 방법**</br>
* 수행중에 지속적으로 확인해 차이가 생기는 경우 경고를 발생
* 빈틈없는 테스트, 프로세스 격리(process isolation), 죽은 프로세스의 재시작 허용, 프로덕션 환경에서 시스템 동작의 측정, 모니터링, 분석하기 ...

### 2-3. 인적 오류
**해결 방법**</br>
* 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라. 잘 설계된 추상화, API, 관리 인터페이스는 잘못된 일은 막을 수 있지만, 지나치게 제한적이면, 사용하지 않을 것이다.
* 사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라. 비 프로덕션 샌드박스(sandbox)를 제공하라.
* 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라. 특히 정상적인 동작에서는 거의 발생하지 않는 코너 케이스(corner case)를 다루는 데 유용하다.
* 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라. 설정 변경 내역을 빠르게 롤백하고, 새로운 코드를 서서히 롤아웃하게 만들고, 이전 계산이 잘못된 경우를 대비해 데이터 재계산 도구를 제공하라.
* 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라. 모니터링을 다른 엔지니어 분야에서는 원격 측정(telemetry)이라고 부른다. 모니터링은 조기에 경고 신호를 보내줄 수 있고, 특정 가정이나 제한을 벗어나는지 확인할 수 있게 한다. 문제가 발생했을 때 지표(metrics)는 문제를 분석하는 데 매우 중요하다.
* 조작 교육과 실습을 시행하라. 까다롭지만, 매우 중요한 측면이다.

## 3. 확장성(scalability)
시스템의 데이터의 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 함

**고민할 점**</br>
* 시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?
* 추가 부하를 다루기 위해 계산 자원은 어떻게 투입할까?

**용어**</br>
확장성: 증가한 부하에 대처하는 시스템 능력

### 3-1. 부하 기술하기
* 부하 매개변수(load parameter): 부하를 나타내는 숫자. 웹 서버의 토당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률. 평균적인 경우가 중요할 수도 있고, 소수의 극단적인 경우가 병목 편상의 원인일 수 있다.

![트위터 데이터 처리 방법1](https://ebrary.net/htm/img/15/554/4.png)
![트위터 데이터 처리 방법2](https://ebrary.net/htm/img/15/554/5.png)
(출처: https://ebrary.net/64604/computer_science/scalability)

### 3-2. 성능 기술하기
**부하가 증가할 때 어떤 일이 일어나는지 기술**</br>
1. 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
2. 부하 매개변수를 증가시켰을 때, 성능이 변하지 않고 유지되길 원한다면, 얼마나 많이 자원을 놀려야 할까?

**성능 수치**</br>
1. 처리량(throughput)
2. 응답 시간(response time) - 클라이언트 관점 > "분포"로 생각해야 하고, "특이 값(outlier)"을 고려해야 함. cf. 지연(latency)
    * 고려해야할 응답시간을 지연시키는 것들: 백그라운드 프로세스의 컨텍스트 스위치, 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지(pause), 디스크에서 읽기를 상제하는 페이지 폴드(page fault), 서버 랙의 기계적인 진동이나 여러 다른 원인
    * 평균(산술 평균)보다는 **백분위(percentile)**로 계산한 중앙값(median)이 더 유용하다.
    * 특정값이 얼마나 좋지 않은지 알아볼 때는 상위 백분위를 봄: 95분위(p95), 99분위(p99), 99.9분위(p999) [꼬리 지연 시간(tail latency)] => 꼬리 지연 증폭(tail latency amplification): 최종 사용자 요청 중 많은 비율의 응답시간이 느려지는 것
    * 백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 자주 등장
    * 선두 차단(head-of-line blocking): 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체되는 것

![성능수치](https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0105.png)
(출처: https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/ch01.html)

### 3-3. 부하 대응 접근 방식
1. 용량 확장(scaling up), 수직확장(vertical scaling): 좀 더 강력한 장비로 이동
2. 규모 확장(sacling out), 수평 확장(horizontal scaling): 다수의 낮은 사양 장비에 부하를 분산. 비공유(shared-nothing) 아키텍처

* 탄력적(elastic): 부하를 감지하면 컴퓨팅 자원을 자동으로 추가하는 것

대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 어플리케이션에 특화되어 있다. 모든 상황에 맞는(one-size-fits-all) 확장 아키텍처(magic scaling source)는 없다. 아키텍처를 결정하는 요소는 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴등이 있다. 특정 애플리케이션에 적합한 확장서을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 이 가정은 곧 부하 매개변수가 된다. 이 가정이 잘못되면 엔지니어링 노력은 헛수고가 되고 최악의 경우 역효과를 낳는다.

## 4. 유지보수성(maintainability)
시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링 + 운영)할 것 => 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 함

* 유지보수: 버그 수정, 시스템 운영 유지, 장애조사, 새로운 플랫폼 적응, 새사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가

### 4-1. 운용성: 운영의 편리함 만들기
운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라.

좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.
* 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 복원
* 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
* 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
* 미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(예를 들어 용량 계획)
* 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
* 설정 변경으로 생기는 시스템 보안 유지보수
* 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
* 개인 인사 이동에도 시스템에 대한 조직의 지식을 보전함

좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만드렁 운영팀이 고부가가치 활동에 노력을 집중
* 런타임 동작과 시스템의 내부에 대한 가시성 제공
* 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원 제공
* 개별 장비 의존성을 회피, 유지 보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함
* 좋은 문서와 이해하기 쉬운 운영 모델 제공
* 적절하게 자기 회복이 가능할 뿐 아리나 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
* 예측 가능하게 동작하고 예기치 않은 상황을 최소화함

### 4-2. 단순성: 복잡도 관리
시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라. 

* 커다란 진흙 덩어리(big ball of mud): 상태 공간의 급증, 모듈간의 강한 커플링, 복잡한 의존성, 일관성 없는 명명과 용어, 성능 문제 해결을 목표로 한 해킹, 임시 방편으로 문제를 해결한 특수 사례
* 우발적 복잡도(accidental complexity)를 줄인다.

**해결방법: 추상화**</br>
좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다. 좋은 추상화는 다른 다양한 애플리케이션에서도 사용 가능하다.(재사용성)

### 4-3. 발전성: 변화를 쉽게 만들기
엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. **민첩성**이 중요 => 애자일 개발 방법론

**유연성(extensibility)**</br>

**수정 가능성(modifiability)**</br>

**적응성(palsticity)**</br>